<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>flappyBird</title>
	<link rel='stylesheet' href='/stylesheets/style.css' />
	<link rel="stylesheet" href="/h5static/flappyBird/css/style.css">
</head>
<body style="width:100%;height:100%;">
	<canvas id="J_flappybird"></canvas>
	<!-- <canvas id="J_land" style="display: none;"></canvas> --><!-- 如果不隐藏掉，嵌套里有一张画布，嵌套外又有一张画布 -->
	<script src="/h5static/flappyBird/js/flappybird.js"></script>
	<script>
		//基础：context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);除了第一个，2-5参数是在原img上设置，后四个是在canvas上设置
		//首先建一块画布
		var screenWidth = document.body.clientWidth;
		var screenHeight = document.body.clientHeight;
		var canvas = document.getElementById('J_flappybird');//canvas对象

		//requestAnimationFrame控制canvas动画
		var RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
		            window.setTimeout(callback, 1000 / 60);
		        };
		//让画布全屏
		canvas.width = screenWidth;
		canvas.height = screenHeight;
		var ctx = canvas.getContext('2d');//上下文对象

		//存放图片
		var images = [
			{name: 'bg_day', src:'/h5static/flappyBird/img/bg_day.png'},
			{name: 'land', src:'/h5static/flappyBird/img/land.png'},
			{name: 'bird0', src:'/h5static/flappyBird/img/bird1_0.png'},
			{name: 'bird1', src:'/h5static/flappyBird/img/bird1_1.png'},
			{name: 'bird2', src:'/h5static/flappyBird/img/bird1_2.png'},
			{name: 'pipe1', src:'/h5static/flappyBird/img/pipe_down.png'},
			{name: 'pipe2', src:'/h5static/flappyBird/img/pipe_up.png'},
			{name: 'springs', src:'/h5static/flappyBird/img/atlas.png'}
		];
		//主动画函数
		//控制requestAnimationFrame频率。教程：https://www.cnblogs.com/kenkofox/p/3849067.html
		var scales = 288/screenWidth;//等比例
		var fps = 8;//越小越慢
		var now;
		var then = Date.now();
		var interval = 1000/fps;
		var delta;
		var gameover = false;//全局变量，判断游戏是否结束
		var animate = '';
		var canScore = false;//是否开始计分
		var birdscore = 0;//得分
		var isStarted = false;//是否开始
		window.onload = function(){
			//new的顺序决定了哪个图在上层
			//点击让小鸟跳跃
			document.onkeydown = function(e){//问题：键盘事件好像只能绑定在document上？
				if(e.keyCode===32){
					isStarted = true;
					bird.fly(4);
				}
			}
			//run();
		};
		
		
		//画天空类
		var Sky = function(img,ctx,initX,speed,count){
			var _self = this;
			this.img = img;
			this.ctx = ctx;//总画布
			this.speed = speed;//地面移动速度
			this.x = initX;//起始位置
			this.count = count;
		};
		Sky.prototype.draw = function(){
			for(var i =0;i<this.count;i++){
				this.ctx.drawImage(this.img, 0, 0, scales*screenWidth, scales*screenHeight, this.x+screenWidth*i, 0, screenWidth, screenHeight);
			}
		};
		Sky.prototype.update = function(){
			this.x -=this.speed;
			if(this.x <-screenWidth){//宽度写活
				this.x = 0;
			}
			this.draw();
		};
		//画地面类
		var Land = function(img,ctx,initX,speed,count){
			var _self = this;
			this.img = img;
			this.ctx = ctx;//总画布
			this.speed = speed;//地面移动速度
			this.x = initX;//起始位置
			this.count = count;
		};
		Land.prototype.draw = function(){
			for(var i =0;i<this.count;i++){
				this.ctx.drawImage(this.img, 584, 0, 336, 112, this.x+(335/scales)*i, screenHeight-112/scales, 336/scales, 112/scales);
			}
		};
		Land.prototype.update = function(){
			this.x -=this.speed;
			if(this.x <-336/scales){
				this.x = 0;
			}
			this.draw();
		};
		//画水管类
		var Pipe = function(img,ctx,initX,speed, gap, initY){
			var _self = this;
			this.img = img;
			this.ctx = ctx;//总画布
			this.speed = speed;//地面移动速度
			this.x = initX;//起始位置X轴
			this.y = initY;//起始位置Y轴,前几个管道初始值要设置下
			this.gap = gap;
			this.pipeTop = ((screenHeight-112/scales)-this.gap)/2+this.y;
			this.pipeBottom = (screenHeight-112/scales)-(((screenHeight-112/scales)-this.gap)/2-this.y);
		};
		Pipe.prototype.draw = function(){
			var skyH = screenHeight-112/scales;//管道占用的高度不算land,

			this.ctx.drawImage(this.img, 112, 966, 52, -scales*((skyH-this.gap)/2+this.y),this.x,0,screenWidth*0.2,(skyH-this.gap)/2+this.y);
			this.ctx.drawImage(this.img, 168, 646, 52, scales*((skyH-this.gap)/2-this.y),this.x,skyH-((skyH-this.gap)/2-this.y),screenWidth*0.2,(skyH-this.gap)/2-this.y);
		};
		Pipe.prototype.update = function(){
			this.x -=this.speed;
			if(this.x <-(screenWidth*0.7)){//宽度写活
				this.x = screenWidth*1.7;
				var negate = [1, -1, 0],
				    direction = negate[Math.floor(Math.random() * negate.length)];
				this.y = parseInt(direction*Math.random()*300)+50;//当管道回到初始值，同时修改上下开口的位置
				this.pipeTop = ((screenHeight-112/scales)-this.gap)/2+this.y;
				this.pipeBottom = (screenHeight-112/scales)-(((screenHeight-112/scales)-this.gap)/2-this.y);
			}
			this.draw();
		};
		//画小鸟类
		var Bird = function(img,ctx,rate,initY){
			var _self = this;
			this.img = img;
			this.ctx = ctx;
			this.wing = 0;//小鸟煽动翅膀计时
			this.rate = rate;//翅膀扑腾临界值，理解为速度,越小越快
			this.upSpeed = 0;//小鸟跳跃初始速度值，用于控制鸟跳跃
			this.grav = 0;//垂直下落的速度，重力加速度，初始为0 ;
			this.x = (screenWidth/2)-(34/scales/2);//小鸟初始水平位置
			this.y = initY;//小鸟初始垂直位置
		};
		Bird.prototype.draw = function(index){
			this.ctx.save();
			this.ctx.translate(this.x+17/scales, this.y+12/scales);//修改canvas的原点到鸟的中心
			this.ctx.rotate(-(Math.PI/6)*this.upSpeed/8);//圆周率*值=角度大小
			this.ctx.translate(-(this.x+17/scales), -(this.y+12/scales));//修改canvas的原点回到最初
			switch(index){
				case 0:this.ctx.drawImage(this.img, 6, 982, 34, 24, this.x, this.y, 34/scales, 24/scales);
					break;
				case 1:this.ctx.drawImage(this.img, 62, 982, 34, 24, this.x, this.y, 34/scales, 24/scales);
					break;
				case 2:this.ctx.drawImage(this.img, 118, 982, 34, 24, this.x, this.y, 34/scales, 24/scales);
					break;
			}
			this.ctx.restore();
		};
		Bird.prototype.fly = function(speed){
			this.wing -=0.1;
			if(this.wing>-this.rate){
				this.draw(0);
			}else if(this.wing>-this.rate*2){
				this.draw(1);
			}else{
				this.draw(2);
				this.wing = 0;
			}
			//小鸟垂直运动
			if(speed&&speed>0){
				this.upSpeed = speed;
			}
			
			if(this.upSpeed){
				this.y -= this.upSpeed*4;//控制弹一次的跨度，越大跳越高
				this.upSpeed -=0.2;//速度衰减速度     
			}else{
				this.y += this.grav*1.2;
			}
			this.draw();
		};
		//画记分牌
		var Blank = function(img, ctx){
			this.img = img;
			this.ctx = ctx;
			//this.score = 0;
		};
		Blank.prototype.draw = function(score){
			this.ctx.drawImage(this.img, 6, 518, 226, 114, (screenWidth-226/scales)/2,(screenHeight-114/scales)/2,226/scales, 114/scales);
			this.ctx.drawImage(this.img, 224, 906, 44, 44, (screenWidth-226/scales)/2+25/scales,(screenHeight-114/scales)/2+43/scales,44/scales, 44/scales);//分数区域显示不同奖牌
			this.ctx.font="bold 60px HarlemNights";          
			//设置绘制分数的字体   
			this.ctx.fillStyle="#FFFFFF";
		    //从坐标点(50,50)开始绘制文字
		    this.ctx.fillText(score, (screenWidth-226/scales)/2+175/scales,(screenHeight-114/scales)/2+50/scales);
		};
		//游戏初始
		/**
		 *思路：新做个canvas用来放这些
		**/
		var Init = function(img, ctx){
			this.img = img;
			this.ctx = ctx;
		};
		Init.prototype.begin = function(){
			this.ctx.drawImage(this.img, 584, 182, 114, 98, (screenWidth-114/scales)/2, (screenHeight-98/scales)/2, 114/scales, 98/scales)
		};
		Init.prototype.restart = function(){};
		Init.prototype.close = function(){};
		Init.prototype.update = function(){
			this.begin();
		};
		//画开始画面
		var imgAtlas = new Image();
			imgAtlas.src =  images[7].src;
		
		var sky=new Sky(imgAtlas,ctx,0,2,2);
		var land=new Land(imgAtlas,ctx,0,5,4);
		var pipe1 = new Pipe(imgAtlas,ctx,screenWidth,2, 500, 200);
		var pipe2 = new Pipe(imgAtlas,ctx,screenWidth*1.8,2, 500, 0);
		var pipe3 = new Pipe(imgAtlas,ctx,screenWidth*2.6,2, 500, -400);
		var bird = new Bird(imgAtlas,ctx,0.8,(screenHeight-98/scales)/2);
		var blank = new Blank(imgAtlas,ctx);//记分牌
		var init = new Init(imgAtlas,ctx);//初始化
		imgAtlas.onload = run;//图片加载完开始动画
		//主动画函数
		function run(){
			var pipes = [pipe1, pipe2, pipe3];
			pipes.forEach(function(item, index){//遍历进入画面的水管开始规则校验
				if((item.x+(screenWidth*0.2))>bird.x&&item.x<screenWidth){
					isGameover(bird, item);
				}
				//计分
				if(item.x<(bird.x+34/scales)&&(item.x+(screenWidth*0.2))>bird.x){
					canScore = true;
				}
				if(bird.x>(item.x+(screenWidth*0.2))&&item.x>0&&canScore){
					canScore = false;
					birdscore++;
					console.log(birdscore);
				};
			});

			if(gameover){
				setTimeout(function(){
					blank.draw(birdscore);
				},100);
				return;
			}else{
				//判断游戏是否开始
				if(!isStarted){
					//画天空
					sky.update();
					//画地面
					land.update();
					//画鸟
					bird.fly();
				}else{
					//画天空
					sky.update();
					//画地面
					land.update();
					//画水管
					pipe1.update();
					pipe2.update();
					pipe3.update();
					//画鸟
					bird.fly();
				}
				//动画执行
				animate = RAF(run);//获取动画RAF的id
			}
		};
		//规则判断
		/**
		 *思路：碰到管子挂，飞出画面挂，碰到地面挂
		**/
		function isGameover(obj1,obj2){//小鸟坐标和死亡区域坐标
			if(((obj1.x+34/scales)>obj2.x)&&(obj1.x<(obj2.x+screenWidth*0.2))&&(obj1.y<obj2.pipeTop||(obj1.y+24/scales)>obj2.pipeBottom)){
				gameover = true;
			}else if(obj1.y<0||(obj1.y+24/scales)>screenHeight){
				gameover = true;
			}
		};
		//拼接数字图片
		function imgNumber(val){
			var num = val.toString();
			console.log(num);
			var arr = num.split('');
			console.log(arr);

		}
		imgNumber(0);
		//绘制背景
		//绘制地面
		/**
		 *思路：drawImage多个图片，并列放到canvas里(类似于轮播图)，通过设置排列图片的起始位置、速度speed来控制canvas内的img移动，移动超过一个图片宽的距离以后起始位置变为0，形成一个无缝滚动的效果。
		**/
		//绘制小鸟
		/**
		 *思路：小鸟可以扇翅膀，定一个初始值this.x，随着RAF，逐渐增加，到一个临界值的时候修改图片，设置三个临界值(0,rate.rate*2);到第三个临界值，this.x归零。
		 *问题：小鸟动起来的是会有叠影（解决：试试雪碧图，通过drawimage参数绘图）
		**/
		/**
		 *效果：初始的时候一直在一个位置飞，第一次点击后有了重力加速度开始自由落体，点击一次上跳一次，上跳玩开始自由落体。掉落到地面后alert();
		 *思路:小鸟只做上下运动(使用drawImage的参数确定小鸟上下位置)。对应两个速度，一个是重力加速度向下固定值，点击的那一下给一个速度向上，小鸟就往上动，然后速度逐渐衰减到重力速度，然后继续依据重力速度移动
		**/
		// var bird = new Bird([images[2].src,images[3].src,images[4].src],ctx,0.8);
		
		//绘制管道
		/**
		 *思路：通过传入随机数this.y来设置上下管道间空隙的位置，同时设置上下管道间隔可配this.gap。
		 *
		**/
		/*辅助函数*/
		//辨别触屏还是PC


	</script>
</body>
</html>